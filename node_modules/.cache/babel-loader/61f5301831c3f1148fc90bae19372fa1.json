{"ast":null,"code":"function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { isArray, isNil } from '../../../services/predicate';\nimport { isDateValue, dateValuesEqual } from './date_value';\nexport var Match = Object.freeze({\n  MUST: 'must',\n  MUST_NOT: 'must_not',\n  isMust: function isMust(match) {\n    return match === Match.MUST;\n  },\n  isMustClause: function isMustClause(clause) {\n    return Match.isMust(clause.match);\n  }\n});\nexport var Operator = Object.freeze({\n  EQ: 'eq',\n  EXACT: 'exact',\n  GT: 'gt',\n  GTE: 'gte',\n  LT: 'lt',\n  LTE: 'lte',\n  isEQ: function isEQ(match) {\n    return match === Operator.EQ;\n  },\n  isEQClause: function isEQClause(clause) {\n    return Operator.isEQ(clause.operator);\n  },\n  isEXACT: function isEXACT(match) {\n    return match === Operator.EXACT;\n  },\n  isEXACTClause: function isEXACTClause(clause) {\n    return Operator.isEXACT(clause.operator);\n  },\n  isRange: function isRange(match) {\n    return Operator.isGT(match) || Operator.isGTE(match) || Operator.isLT(match) || Operator.isLTE(match);\n  },\n  isRangeClause: function isRangeClause(clause) {\n    return Operator.isRange(clause.operator);\n  },\n  isGT: function isGT(match) {\n    return match === Operator.GT;\n  },\n  isGTClause: function isGTClause(clause) {\n    return Operator.isGT(clause.operator);\n  },\n  isGTE: function isGTE(match) {\n    return match === Operator.GTE;\n  },\n  isGTEClause: function isGTEClause(clause) {\n    return Operator.isGTE(clause.operator);\n  },\n  isLT: function isLT(match) {\n    return match === Operator.LT;\n  },\n  isLTClause: function isLTClause(clause) {\n    return Operator.isLT(clause.operator);\n  },\n  isLTE: function isLTE(match) {\n    return match === Operator.LTE;\n  },\n  isLTEClause: function isLTEClause(clause) {\n    return Operator.isLTE(clause.operator);\n  }\n});\nvar Term = Object.freeze({\n  TYPE: 'term',\n  isInstance: function isInstance(clause) {\n    return clause.type === Term.TYPE;\n  },\n  must: function must(value) {\n    return {\n      type: Term.TYPE,\n      value: value,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(value) {\n    return {\n      type: Term.TYPE,\n      value: value,\n      match: Match.MUST_NOT\n    };\n  }\n});\nvar Group = Object.freeze({\n  TYPE: 'group',\n  isInstance: function isInstance(clause) {\n    return clause.type === Group.TYPE;\n  },\n  must: function must(value) {\n    return {\n      type: Group.TYPE,\n      value: value,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(value) {\n    return {\n      type: Group.TYPE,\n      value: value,\n      match: Match.MUST_NOT\n    };\n  }\n});\nvar Field = Object.freeze({\n  TYPE: 'field',\n  isInstance: function isInstance(clause) {\n    return clause.type === Field.TYPE;\n  },\n  must: {\n    eq: function eq(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.EQ\n      };\n    },\n    exact: function exact(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.EXACT\n      };\n    },\n    gt: function gt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.GT\n      };\n    },\n    gte: function gte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.GTE\n      };\n    },\n    lt: function lt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.LT\n      };\n    },\n    lte: function lte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.LTE\n      };\n    }\n  },\n  mustNot: {\n    eq: function eq(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.EQ\n      };\n    },\n    exact: function exact(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.EXACT\n      };\n    },\n    gt: function gt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.GT\n      };\n    },\n    gte: function gte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.GTE\n      };\n    },\n    lt: function lt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.LT\n      };\n    },\n    lte: function lte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.LTE\n      };\n    }\n  }\n});\nvar Is = Object.freeze({\n  TYPE: 'is',\n  isInstance: function isInstance(clause) {\n    return clause.type === Is.TYPE;\n  },\n  must: function must(flag) {\n    return {\n      type: Is.TYPE,\n      flag: flag,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(flag) {\n    return {\n      type: Is.TYPE,\n      flag: flag,\n      match: Match.MUST_NOT\n    };\n  }\n});\n\nvar valuesEqual = function valuesEqual(v1, v2) {\n  if (isDateValue(v1)) {\n    return dateValuesEqual(v1, v2);\n  }\n\n  return v1 === v2;\n};\n\nvar arrayIncludesValue = function arrayIncludesValue(array, value) {\n  return array.some(function (item) {\n    return valuesEqual(item, value);\n  });\n};\n/**\n * The AST structure is an array of clauses. There are 3 types of clauses that are supported:\n *\n * :term:\n * Holds a VALUE and an OCCUR. The OCCUR indicates whether the value must match or must not match. Default\n * clauses are not associated with any specific field - when executing the search, one can specify what are\n * the default fields that the default clauses will be matched against.\n *\n * :field:\n * Like the `term` clause, holds a VALUE and an MATCH, but this clause also specifies the field that the\n * value will be matched against.\n *\n * :is:\n * Holds a FLAG and indicates whether this flag must be applied or must not be applied. Typically this clause\n * matches against boolean values of a record (e.g. \"is:online\", \"is:internal\", \"is:on\", etc..)\n *\n * This AST is immutable - every \"mutating\" operation returns a newly mutated AST.\n */\n\n\nexport var _AST =\n/*#__PURE__*/\nfunction () {\n  _createClass(_AST, null, [{\n    key: \"create\",\n    value: function create(clauses) {\n      return new _AST(clauses);\n    }\n  }]);\n\n  function _AST() {\n    var clauses = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, _AST);\n\n    this._clauses = clauses;\n    this._indexedClauses = clauses.reduce(function (map, clause) {\n      switch (clause.type) {\n        case Field.TYPE:\n          if (!map.field[clause.field]) {\n            map.field[clause.field] = [];\n          }\n\n          map.field[clause.field].push(clause);\n          return map;\n\n        case Is.TYPE:\n          map.is[clause.flag] = clause;\n          return map;\n\n        case Term.TYPE:\n          map.term.push(clause);\n          return map;\n\n        case Group.TYPE:\n          map.group.push(clause);\n          return map;\n\n        default:\n          throw new Error(\"Unknown query clause type [\".concat(clause.type, \"]\"));\n      }\n    }, {\n      field: {},\n      is: {},\n      term: [],\n      group: []\n    });\n  }\n\n  _createClass(_AST, [{\n    key: \"getTermClauses\",\n    value: function getTermClauses() {\n      return this._indexedClauses.term;\n    }\n  }, {\n    key: \"getTermClause\",\n    value: function getTermClause(value) {\n      var clauses = this.getTermClauses();\n      return clauses.find(function (clause) {\n        return valuesEqual(clause.value, value);\n      });\n    }\n  }, {\n    key: \"getFieldNames\",\n    value: function getFieldNames() {\n      return Object.keys(this._indexedClauses.field);\n    }\n  }, {\n    key: \"getFieldClauses\",\n    value: function getFieldClauses() {\n      var field = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      return field ? this._indexedClauses.field[field] : this._clauses.filter(Field.isInstance);\n    }\n  }, {\n    key: \"getFieldClause\",\n    value: function getFieldClause(field, predicate) {\n      var clauses = this.getFieldClauses(field);\n\n      if (clauses) {\n        return clauses.find(predicate);\n      }\n    }\n  }, {\n    key: \"hasOrFieldClause\",\n    value: function hasOrFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var clauses = this.getFieldClause(field, function (clause) {\n        return isArray(clause.value);\n      });\n\n      if (!clauses) {\n        return false;\n      }\n\n      return isNil(value) || clauses.some(function (clause) {\n        return arrayIncludesValue(clause.value, value);\n      });\n    }\n  }, {\n    key: \"getOrFieldClause\",\n    value: function getOrFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return this.getFieldClause(field, function (clause) {\n        return isArray(clause.value) && (isNil(value) || arrayIncludesValue(clause.value, value));\n      });\n    }\n  }, {\n    key: \"addOrFieldValue\",\n    value: function addOrFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Operator.EQ;\n      var existingClause = this.getOrFieldClause(field);\n\n      if (!existingClause) {\n        var newClause = must ? Field.must[operator](field, [value]) : Field.mustNot[operator](field, [value]);\n        return new _AST(_toConsumableArray(this._clauses).concat([newClause]));\n      }\n\n      var clauses = this._clauses.map(function (clause) {\n        if (clause === existingClause) {\n          clause.value.push(value);\n        }\n\n        return clause;\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeOrFieldValue\",\n    value: function removeOrFieldValue(field, value) {\n      var existingClause = this.getOrFieldClause(field, value);\n\n      if (!existingClause) {\n        return new _AST(_toConsumableArray(this._clauses));\n      }\n\n      var clauses = this._clauses.reduce(function (clauses, clause) {\n        if (clause !== existingClause) {\n          clauses.push(clause);\n          return clauses;\n        }\n\n        var filteredValue = clause.value.filter(function (val) {\n          return !valuesEqual(val, value);\n        });\n\n        if (filteredValue.length === 0) {\n          return clauses;\n        }\n\n        clauses.push(_objectSpread({}, clause, {\n          value: filteredValue\n        }));\n        return clauses;\n      }, []);\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeOrFieldClauses\",\n    value: function removeOrFieldClauses(field) {\n      var clauses = this._clauses.filter(function (clause) {\n        return !Field.isInstance(clause) || clause.field !== field || !isArray(clause.value);\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"hasSimpleFieldClause\",\n    value: function hasSimpleFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var clauses = this.getFieldClause(field, function (clause) {\n        return !isArray(clause.value);\n      });\n\n      if (!clauses) {\n        return false;\n      }\n\n      return isNil(value) || clauses.some(function (clause) {\n        return valuesEqual(clause.value, value);\n      });\n    }\n  }, {\n    key: \"getSimpleFieldClause\",\n    value: function getSimpleFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return this.getFieldClause(field, function (clause) {\n        return !isArray(clause.value) && (isNil(value) || valuesEqual(clause.value, value));\n      });\n    }\n  }, {\n    key: \"addSimpleFieldValue\",\n    value: function addSimpleFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Operator.EQ;\n      var clause = must ? Field.must[operator](field, value) : Field.mustNot[operator](field, value);\n      return this.addClause(clause);\n    }\n  }, {\n    key: \"removeSimpleFieldValue\",\n    value: function removeSimpleFieldValue(field, value) {\n      var existingClause = this.getSimpleFieldClause(field, value);\n\n      if (!existingClause) {\n        return new _AST(_toConsumableArray(this._clauses));\n      }\n\n      var clauses = this._clauses.filter(function (clause) {\n        return clause !== existingClause;\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeSimpleFieldClauses\",\n    value: function removeSimpleFieldClauses(field) {\n      var clauses = this._clauses.filter(function (clause) {\n        return !Field.isInstance(clause) || clause.field !== field || isArray(clause.value);\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"getIsClauses\",\n    value: function getIsClauses() {\n      return Object.values(this._indexedClauses.is);\n    }\n  }, {\n    key: \"getIsClause\",\n    value: function getIsClause(flag) {\n      return this._indexedClauses.is[flag];\n    }\n  }, {\n    key: \"removeIsClause\",\n    value: function removeIsClause(flag) {\n      return new _AST(this._clauses.filter(function (clause) {\n        return !Is.isInstance(clause) || clause.flag !== flag;\n      }));\n    }\n  }, {\n    key: \"getGroupClauses\",\n    value: function getGroupClauses() {\n      return Object.values(this._indexedClauses.group);\n    }\n    /**\n     * Creates and returns a new AST with the given clause added to the current clauses. If\n     * the current clauses already include a similar clause, it will be (in-place) replaced by\n     * the given clause. Whether a clause is similar to the given one depends on the type of the clause.\n     * Two clauses are similar if:\n     *\n     * - they are both of the same type\n     * - if they are `default` clauses, they must have the same value\n     * - if they are `term` clauses, they must have the same fields and values\n     * - if they are `is` clauses, they must have the same flags\n     *\n     * The reasoning behind not including the `match` attributes of the clauses in the rules above, stems\n     * in the fact that the AST clauses are ANDed, and having two similar clauses with two different\n     * match attributes creates a logically contradicted AST (e.g. what does it mean to\n     * \"(must have x) AND (must not have x)\"?)\n     *\n     * note:  in-place replacement means the given clause will be placed in the same position as the one it\n     *        replaced\n     */\n\n  }, {\n    key: \"addClause\",\n    value: function addClause(newClause) {\n      var added = false;\n\n      var newClauses = this._clauses.reduce(function (clauses, clause) {\n        if (newClause.type !== clause.type) {\n          clauses.push(clause);\n          return clauses;\n        }\n\n        switch (newClause.type) {\n          case Term.TYPE:\n            if (newClause.value !== clause.value) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          case Field.TYPE:\n            if (newClause.field !== clause.field || newClause.value !== clause.value) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          case Is.TYPE:\n            if (newClause.flag !== clause.flag) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          default:\n            throw new Error(\"unknown clause type [\".concat(newClause.type, \"]\"));\n        }\n\n        added = true;\n        clauses.push(newClause);\n        return clauses;\n      }, []);\n\n      if (!added) {\n        newClauses.push(newClause);\n      }\n\n      return new _AST(newClauses);\n    }\n  }, {\n    key: \"clauses\",\n    get: function get() {\n      return this._clauses;\n    }\n  }]);\n\n  return _AST;\n}();\nexport var AST = Object.freeze({\n  Match: Match,\n  Operator: Operator,\n  Term: Term,\n  Group: Group,\n  Field: Field,\n  Is: Is,\n  create: function create(clauses) {\n    return new _AST(clauses);\n  }\n});","map":{"version":3,"sources":["/Users/timothybowen/Documents/Development/social-one/node_modules/@elastic/eui/es/components/search_bar/query/ast.js"],"names":["_objectSpread","target","i","arguments","length","source","ownKeys","Object","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","obj","value","defineProperty","configurable","writable","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","prototype","toString","call","Array","from","isArray","arr2","_classCallCheck","instance","Constructor","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","isNil","isDateValue","dateValuesEqual","Match","freeze","MUST","MUST_NOT","isMust","match","isMustClause","clause","Operator","EQ","EXACT","GT","GTE","LT","LTE","isEQ","isEQClause","operator","isEXACT","isEXACTClause","isRange","isGT","isGTE","isLT","isLTE","isRangeClause","isGTClause","isGTEClause","isLTClause","isLTEClause","Term","TYPE","isInstance","type","must","mustNot","Group","Field","eq","field","exact","gt","gte","lt","lte","Is","flag","valuesEqual","v1","v2","arrayIncludesValue","array","some","item","_AST","create","clauses","undefined","_clauses","_indexedClauses","reduce","map","push","is","term","group","Error","getTermClauses","getTermClause","find","getFieldNames","getFieldClauses","getFieldClause","predicate","hasOrFieldClause","getOrFieldClause","addOrFieldValue","existingClause","newClause","removeOrFieldValue","filteredValue","val","removeOrFieldClauses","hasSimpleFieldClause","getSimpleFieldClause","addSimpleFieldValue","addClause","removeSimpleFieldValue","removeSimpleFieldClauses","getIsClauses","values","getIsClause","removeIsClause","getGroupClauses","added","newClauses","get","AST"],"mappings":"AAAA,SAASA,aAAT,CAAuBC,MAAvB,EAA+B;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAT,IAAgB,IAAhB,GAAuBC,SAAS,CAACD,CAAD,CAAhC,GAAsC,EAAnD;AAAuD,QAAII,OAAO,GAAGC,MAAM,CAACC,IAAP,CAAYH,MAAZ,CAAd;;AAAmC,QAAI,OAAOE,MAAM,CAACE,qBAAd,KAAwC,UAA5C,EAAwD;AAAEH,MAAAA,OAAO,GAAGA,OAAO,CAACI,MAAR,CAAeH,MAAM,CAACE,qBAAP,CAA6BJ,MAA7B,EAAqCM,MAArC,CAA4C,UAAUC,GAAV,EAAe;AAAE,eAAOL,MAAM,CAACM,wBAAP,CAAgCR,MAAhC,EAAwCO,GAAxC,EAA6CE,UAApD;AAAiE,OAA9H,CAAf,CAAV;AAA4J;;AAACR,IAAAA,OAAO,CAACS,OAAR,CAAgB,UAAUC,GAAV,EAAe;AAAEC,MAAAA,eAAe,CAAChB,MAAD,EAASe,GAAT,EAAcX,MAAM,CAACW,GAAD,CAApB,CAAf;AAA4C,KAA7E;AAAiF;;AAAC,SAAOf,MAAP;AAAgB;;AAEje,SAASgB,eAAT,CAAyBC,GAAzB,EAA8BF,GAA9B,EAAmCG,KAAnC,EAA0C;AAAE,MAAIH,GAAG,IAAIE,GAAX,EAAgB;AAAEX,IAAAA,MAAM,CAACa,cAAP,CAAsBF,GAAtB,EAA2BF,GAA3B,EAAgC;AAAEG,MAAAA,KAAK,EAAEA,KAAT;AAAgBL,MAAAA,UAAU,EAAE,IAA5B;AAAkCO,MAAAA,YAAY,EAAE,IAAhD;AAAsDC,MAAAA,QAAQ,EAAE;AAAhE,KAAhC;AAA0G,GAA5H,MAAkI;AAAEJ,IAAAA,GAAG,CAACF,GAAD,CAAH,GAAWG,KAAX;AAAmB;;AAAC,SAAOD,GAAP;AAAa;;AAEjN,SAASK,kBAAT,CAA4BC,GAA5B,EAAiC;AAAE,SAAOC,kBAAkB,CAACD,GAAD,CAAlB,IAA2BE,gBAAgB,CAACF,GAAD,CAA3C,IAAoDG,kBAAkB,EAA7E;AAAkF;;AAErH,SAASA,kBAAT,GAA8B;AAAE,QAAM,IAAIC,SAAJ,CAAc,iDAAd,CAAN;AAAyE;;AAEzG,SAASF,gBAAT,CAA0BG,IAA1B,EAAgC;AAAE,MAAIC,MAAM,CAACC,QAAP,IAAmBxB,MAAM,CAACsB,IAAD,CAAzB,IAAmCtB,MAAM,CAACyB,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BL,IAA/B,MAAyC,oBAAhF,EAAsG,OAAOM,KAAK,CAACC,IAAN,CAAWP,IAAX,CAAP;AAA0B;;AAElK,SAASJ,kBAAT,CAA4BD,GAA5B,EAAiC;AAAE,MAAIW,KAAK,CAACE,OAAN,CAAcb,GAAd,CAAJ,EAAwB;AAAE,SAAK,IAAItB,CAAC,GAAG,CAAR,EAAWoC,IAAI,GAAG,IAAIH,KAAJ,CAAUX,GAAG,CAACpB,MAAd,CAAvB,EAA8CF,CAAC,GAAGsB,GAAG,CAACpB,MAAtD,EAA8DF,CAAC,EAA/D,EAAmE;AAAEoC,MAAAA,IAAI,CAACpC,CAAD,CAAJ,GAAUsB,GAAG,CAACtB,CAAD,CAAb;AAAmB;;AAAC,WAAOoC,IAAP;AAAc;AAAE;;AAEtK,SAASC,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;AAAE,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIb,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,SAASc,iBAAT,CAA2BzC,MAA3B,EAAmC0C,KAAnC,EAA0C;AAAE,OAAK,IAAIzC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyC,KAAK,CAACvC,MAA1B,EAAkCF,CAAC,EAAnC,EAAuC;AAAE,QAAI0C,UAAU,GAAGD,KAAK,CAACzC,CAAD,CAAtB;AAA2B0C,IAAAA,UAAU,CAAC9B,UAAX,GAAwB8B,UAAU,CAAC9B,UAAX,IAAyB,KAAjD;AAAwD8B,IAAAA,UAAU,CAACvB,YAAX,GAA0B,IAA1B;AAAgC,QAAI,WAAWuB,UAAf,EAA2BA,UAAU,CAACtB,QAAX,GAAsB,IAAtB;AAA4Bf,IAAAA,MAAM,CAACa,cAAP,CAAsBnB,MAAtB,EAA8B2C,UAAU,CAAC5B,GAAzC,EAA8C4B,UAA9C;AAA4D;AAAE;;AAE7T,SAASC,YAAT,CAAsBJ,WAAtB,EAAmCK,UAAnC,EAA+CC,WAA/C,EAA4D;AAAE,MAAID,UAAJ,EAAgBJ,iBAAiB,CAACD,WAAW,CAACT,SAAb,EAAwBc,UAAxB,CAAjB;AAAsD,MAAIC,WAAJ,EAAiBL,iBAAiB,CAACD,WAAD,EAAcM,WAAd,CAAjB;AAA6C,SAAON,WAAP;AAAqB;;AAEvN,SAASJ,OAAT,EAAkBW,KAAlB,QAA+B,6BAA/B;AACA,SAASC,WAAT,EAAsBC,eAAtB,QAA6C,cAA7C;AACA,OAAO,IAAIC,KAAK,GAAG5C,MAAM,CAAC6C,MAAP,CAAc;AAC/BC,EAAAA,IAAI,EAAE,MADyB;AAE/BC,EAAAA,QAAQ,EAAE,UAFqB;AAG/BC,EAAAA,MAAM,EAAE,SAASA,MAAT,CAAgBC,KAAhB,EAAuB;AAC7B,WAAOA,KAAK,KAAKL,KAAK,CAACE,IAAvB;AACD,GAL8B;AAM/BI,EAAAA,YAAY,EAAE,SAASA,YAAT,CAAsBC,MAAtB,EAA8B;AAC1C,WAAOP,KAAK,CAACI,MAAN,CAAaG,MAAM,CAACF,KAApB,CAAP;AACD;AAR8B,CAAd,CAAZ;AAUP,OAAO,IAAIG,QAAQ,GAAGpD,MAAM,CAAC6C,MAAP,CAAc;AAClCQ,EAAAA,EAAE,EAAE,IAD8B;AAElCC,EAAAA,KAAK,EAAE,OAF2B;AAGlCC,EAAAA,EAAE,EAAE,IAH8B;AAIlCC,EAAAA,GAAG,EAAE,KAJ6B;AAKlCC,EAAAA,EAAE,EAAE,IAL8B;AAMlCC,EAAAA,GAAG,EAAE,KAN6B;AAOlCC,EAAAA,IAAI,EAAE,SAASA,IAAT,CAAcV,KAAd,EAAqB;AACzB,WAAOA,KAAK,KAAKG,QAAQ,CAACC,EAA1B;AACD,GATiC;AAUlCO,EAAAA,UAAU,EAAE,SAASA,UAAT,CAAoBT,MAApB,EAA4B;AACtC,WAAOC,QAAQ,CAACO,IAAT,CAAcR,MAAM,CAACU,QAArB,CAAP;AACD,GAZiC;AAalCC,EAAAA,OAAO,EAAE,SAASA,OAAT,CAAiBb,KAAjB,EAAwB;AAC/B,WAAOA,KAAK,KAAKG,QAAQ,CAACE,KAA1B;AACD,GAfiC;AAgBlCS,EAAAA,aAAa,EAAE,SAASA,aAAT,CAAuBZ,MAAvB,EAA+B;AAC5C,WAAOC,QAAQ,CAACU,OAAT,CAAiBX,MAAM,CAACU,QAAxB,CAAP;AACD,GAlBiC;AAmBlCG,EAAAA,OAAO,EAAE,SAASA,OAAT,CAAiBf,KAAjB,EAAwB;AAC/B,WAAOG,QAAQ,CAACa,IAAT,CAAchB,KAAd,KAAwBG,QAAQ,CAACc,KAAT,CAAejB,KAAf,CAAxB,IAAiDG,QAAQ,CAACe,IAAT,CAAclB,KAAd,CAAjD,IAAyEG,QAAQ,CAACgB,KAAT,CAAenB,KAAf,CAAhF;AACD,GArBiC;AAsBlCoB,EAAAA,aAAa,EAAE,SAASA,aAAT,CAAuBlB,MAAvB,EAA+B;AAC5C,WAAOC,QAAQ,CAACY,OAAT,CAAiBb,MAAM,CAACU,QAAxB,CAAP;AACD,GAxBiC;AAyBlCI,EAAAA,IAAI,EAAE,SAASA,IAAT,CAAchB,KAAd,EAAqB;AACzB,WAAOA,KAAK,KAAKG,QAAQ,CAACG,EAA1B;AACD,GA3BiC;AA4BlCe,EAAAA,UAAU,EAAE,SAASA,UAAT,CAAoBnB,MAApB,EAA4B;AACtC,WAAOC,QAAQ,CAACa,IAAT,CAAcd,MAAM,CAACU,QAArB,CAAP;AACD,GA9BiC;AA+BlCK,EAAAA,KAAK,EAAE,SAASA,KAAT,CAAejB,KAAf,EAAsB;AAC3B,WAAOA,KAAK,KAAKG,QAAQ,CAACI,GAA1B;AACD,GAjCiC;AAkClCe,EAAAA,WAAW,EAAE,SAASA,WAAT,CAAqBpB,MAArB,EAA6B;AACxC,WAAOC,QAAQ,CAACc,KAAT,CAAef,MAAM,CAACU,QAAtB,CAAP;AACD,GApCiC;AAqClCM,EAAAA,IAAI,EAAE,SAASA,IAAT,CAAclB,KAAd,EAAqB;AACzB,WAAOA,KAAK,KAAKG,QAAQ,CAACK,EAA1B;AACD,GAvCiC;AAwClCe,EAAAA,UAAU,EAAE,SAASA,UAAT,CAAoBrB,MAApB,EAA4B;AACtC,WAAOC,QAAQ,CAACe,IAAT,CAAchB,MAAM,CAACU,QAArB,CAAP;AACD,GA1CiC;AA2ClCO,EAAAA,KAAK,EAAE,SAASA,KAAT,CAAenB,KAAf,EAAsB;AAC3B,WAAOA,KAAK,KAAKG,QAAQ,CAACM,GAA1B;AACD,GA7CiC;AA8ClCe,EAAAA,WAAW,EAAE,SAASA,WAAT,CAAqBtB,MAArB,EAA6B;AACxC,WAAOC,QAAQ,CAACgB,KAAT,CAAejB,MAAM,CAACU,QAAtB,CAAP;AACD;AAhDiC,CAAd,CAAf;AAkDP,IAAIa,IAAI,GAAG1E,MAAM,CAAC6C,MAAP,CAAc;AACvB8B,EAAAA,IAAI,EAAE,MADiB;AAEvBC,EAAAA,UAAU,EAAE,SAASA,UAAT,CAAoBzB,MAApB,EAA4B;AACtC,WAAOA,MAAM,CAAC0B,IAAP,KAAgBH,IAAI,CAACC,IAA5B;AACD,GAJsB;AAKvBG,EAAAA,IAAI,EAAE,SAASA,IAAT,CAAclE,KAAd,EAAqB;AACzB,WAAO;AACLiE,MAAAA,IAAI,EAAEH,IAAI,CAACC,IADN;AAEL/D,MAAAA,KAAK,EAAEA,KAFF;AAGLqC,MAAAA,KAAK,EAAEL,KAAK,CAACE;AAHR,KAAP;AAKD,GAXsB;AAYvBiC,EAAAA,OAAO,EAAE,SAASA,OAAT,CAAiBnE,KAAjB,EAAwB;AAC/B,WAAO;AACLiE,MAAAA,IAAI,EAAEH,IAAI,CAACC,IADN;AAEL/D,MAAAA,KAAK,EAAEA,KAFF;AAGLqC,MAAAA,KAAK,EAAEL,KAAK,CAACG;AAHR,KAAP;AAKD;AAlBsB,CAAd,CAAX;AAoBA,IAAIiC,KAAK,GAAGhF,MAAM,CAAC6C,MAAP,CAAc;AACxB8B,EAAAA,IAAI,EAAE,OADkB;AAExBC,EAAAA,UAAU,EAAE,SAASA,UAAT,CAAoBzB,MAApB,EAA4B;AACtC,WAAOA,MAAM,CAAC0B,IAAP,KAAgBG,KAAK,CAACL,IAA7B;AACD,GAJuB;AAKxBG,EAAAA,IAAI,EAAE,SAASA,IAAT,CAAclE,KAAd,EAAqB;AACzB,WAAO;AACLiE,MAAAA,IAAI,EAAEG,KAAK,CAACL,IADP;AAEL/D,MAAAA,KAAK,EAAEA,KAFF;AAGLqC,MAAAA,KAAK,EAAEL,KAAK,CAACE;AAHR,KAAP;AAKD,GAXuB;AAYxBiC,EAAAA,OAAO,EAAE,SAASA,OAAT,CAAiBnE,KAAjB,EAAwB;AAC/B,WAAO;AACLiE,MAAAA,IAAI,EAAEG,KAAK,CAACL,IADP;AAEL/D,MAAAA,KAAK,EAAEA,KAFF;AAGLqC,MAAAA,KAAK,EAAEL,KAAK,CAACG;AAHR,KAAP;AAKD;AAlBuB,CAAd,CAAZ;AAoBA,IAAIkC,KAAK,GAAGjF,MAAM,CAAC6C,MAAP,CAAc;AACxB8B,EAAAA,IAAI,EAAE,OADkB;AAExBC,EAAAA,UAAU,EAAE,SAASA,UAAT,CAAoBzB,MAApB,EAA4B;AACtC,WAAOA,MAAM,CAAC0B,IAAP,KAAgBI,KAAK,CAACN,IAA7B;AACD,GAJuB;AAKxBG,EAAAA,IAAI,EAAE;AACJI,IAAAA,EAAE,EAAE,SAASA,EAAT,CAAYC,KAAZ,EAAmBvE,KAAnB,EAA0B;AAC5B,aAAO;AACLiE,QAAAA,IAAI,EAAEI,KAAK,CAACN,IADP;AAELQ,QAAAA,KAAK,EAAEA,KAFF;AAGLvE,QAAAA,KAAK,EAAEA,KAHF;AAILqC,QAAAA,KAAK,EAAEL,KAAK,CAACE,IAJR;AAKLe,QAAAA,QAAQ,EAAET,QAAQ,CAACC;AALd,OAAP;AAOD,KATG;AAUJ+B,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAeD,KAAf,EAAsBvE,KAAtB,EAA6B;AAClC,aAAO;AACLiE,QAAAA,IAAI,EAAEI,KAAK,CAACN,IADP;AAELQ,QAAAA,KAAK,EAAEA,KAFF;AAGLvE,QAAAA,KAAK,EAAEA,KAHF;AAILqC,QAAAA,KAAK,EAAEL,KAAK,CAACE,IAJR;AAKLe,QAAAA,QAAQ,EAAET,QAAQ,CAACE;AALd,OAAP;AAOD,KAlBG;AAmBJ+B,IAAAA,EAAE,EAAE,SAASA,EAAT,CAAYF,KAAZ,EAAmBvE,KAAnB,EAA0B;AAC5B,aAAO;AACLiE,QAAAA,IAAI,EAAEI,KAAK,CAACN,IADP;AAELQ,QAAAA,KAAK,EAAEA,KAFF;AAGLvE,QAAAA,KAAK,EAAEA,KAHF;AAILqC,QAAAA,KAAK,EAAEL,KAAK,CAACE,IAJR;AAKLe,QAAAA,QAAQ,EAAET,QAAQ,CAACG;AALd,OAAP;AAOD,KA3BG;AA4BJ+B,IAAAA,GAAG,EAAE,SAASA,GAAT,CAAaH,KAAb,EAAoBvE,KAApB,EAA2B;AAC9B,aAAO;AACLiE,QAAAA,IAAI,EAAEI,KAAK,CAACN,IADP;AAELQ,QAAAA,KAAK,EAAEA,KAFF;AAGLvE,QAAAA,KAAK,EAAEA,KAHF;AAILqC,QAAAA,KAAK,EAAEL,KAAK,CAACE,IAJR;AAKLe,QAAAA,QAAQ,EAAET,QAAQ,CAACI;AALd,OAAP;AAOD,KApCG;AAqCJ+B,IAAAA,EAAE,EAAE,SAASA,EAAT,CAAYJ,KAAZ,EAAmBvE,KAAnB,EAA0B;AAC5B,aAAO;AACLiE,QAAAA,IAAI,EAAEI,KAAK,CAACN,IADP;AAELQ,QAAAA,KAAK,EAAEA,KAFF;AAGLvE,QAAAA,KAAK,EAAEA,KAHF;AAILqC,QAAAA,KAAK,EAAEL,KAAK,CAACE,IAJR;AAKLe,QAAAA,QAAQ,EAAET,QAAQ,CAACK;AALd,OAAP;AAOD,KA7CG;AA8CJ+B,IAAAA,GAAG,EAAE,SAASA,GAAT,CAAaL,KAAb,EAAoBvE,KAApB,EAA2B;AAC9B,aAAO;AACLiE,QAAAA,IAAI,EAAEI,KAAK,CAACN,IADP;AAELQ,QAAAA,KAAK,EAAEA,KAFF;AAGLvE,QAAAA,KAAK,EAAEA,KAHF;AAILqC,QAAAA,KAAK,EAAEL,KAAK,CAACE,IAJR;AAKLe,QAAAA,QAAQ,EAAET,QAAQ,CAACM;AALd,OAAP;AAOD;AAtDG,GALkB;AA6DxBqB,EAAAA,OAAO,EAAE;AACPG,IAAAA,EAAE,EAAE,SAASA,EAAT,CAAYC,KAAZ,EAAmBvE,KAAnB,EAA0B;AAC5B,aAAO;AACLiE,QAAAA,IAAI,EAAEI,KAAK,CAACN,IADP;AAELQ,QAAAA,KAAK,EAAEA,KAFF;AAGLvE,QAAAA,KAAK,EAAEA,KAHF;AAILqC,QAAAA,KAAK,EAAEL,KAAK,CAACG,QAJR;AAKLc,QAAAA,QAAQ,EAAET,QAAQ,CAACC;AALd,OAAP;AAOD,KATM;AAUP+B,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAeD,KAAf,EAAsBvE,KAAtB,EAA6B;AAClC,aAAO;AACLiE,QAAAA,IAAI,EAAEI,KAAK,CAACN,IADP;AAELQ,QAAAA,KAAK,EAAEA,KAFF;AAGLvE,QAAAA,KAAK,EAAEA,KAHF;AAILqC,QAAAA,KAAK,EAAEL,KAAK,CAACG,QAJR;AAKLc,QAAAA,QAAQ,EAAET,QAAQ,CAACE;AALd,OAAP;AAOD,KAlBM;AAmBP+B,IAAAA,EAAE,EAAE,SAASA,EAAT,CAAYF,KAAZ,EAAmBvE,KAAnB,EAA0B;AAC5B,aAAO;AACLiE,QAAAA,IAAI,EAAEI,KAAK,CAACN,IADP;AAELQ,QAAAA,KAAK,EAAEA,KAFF;AAGLvE,QAAAA,KAAK,EAAEA,KAHF;AAILqC,QAAAA,KAAK,EAAEL,KAAK,CAACG,QAJR;AAKLc,QAAAA,QAAQ,EAAET,QAAQ,CAACG;AALd,OAAP;AAOD,KA3BM;AA4BP+B,IAAAA,GAAG,EAAE,SAASA,GAAT,CAAaH,KAAb,EAAoBvE,KAApB,EAA2B;AAC9B,aAAO;AACLiE,QAAAA,IAAI,EAAEI,KAAK,CAACN,IADP;AAELQ,QAAAA,KAAK,EAAEA,KAFF;AAGLvE,QAAAA,KAAK,EAAEA,KAHF;AAILqC,QAAAA,KAAK,EAAEL,KAAK,CAACG,QAJR;AAKLc,QAAAA,QAAQ,EAAET,QAAQ,CAACI;AALd,OAAP;AAOD,KApCM;AAqCP+B,IAAAA,EAAE,EAAE,SAASA,EAAT,CAAYJ,KAAZ,EAAmBvE,KAAnB,EAA0B;AAC5B,aAAO;AACLiE,QAAAA,IAAI,EAAEI,KAAK,CAACN,IADP;AAELQ,QAAAA,KAAK,EAAEA,KAFF;AAGLvE,QAAAA,KAAK,EAAEA,KAHF;AAILqC,QAAAA,KAAK,EAAEL,KAAK,CAACG,QAJR;AAKLc,QAAAA,QAAQ,EAAET,QAAQ,CAACK;AALd,OAAP;AAOD,KA7CM;AA8CP+B,IAAAA,GAAG,EAAE,SAASA,GAAT,CAAaL,KAAb,EAAoBvE,KAApB,EAA2B;AAC9B,aAAO;AACLiE,QAAAA,IAAI,EAAEI,KAAK,CAACN,IADP;AAELQ,QAAAA,KAAK,EAAEA,KAFF;AAGLvE,QAAAA,KAAK,EAAEA,KAHF;AAILqC,QAAAA,KAAK,EAAEL,KAAK,CAACG,QAJR;AAKLc,QAAAA,QAAQ,EAAET,QAAQ,CAACM;AALd,OAAP;AAOD;AAtDM;AA7De,CAAd,CAAZ;AAsHA,IAAI+B,EAAE,GAAGzF,MAAM,CAAC6C,MAAP,CAAc;AACrB8B,EAAAA,IAAI,EAAE,IADe;AAErBC,EAAAA,UAAU,EAAE,SAASA,UAAT,CAAoBzB,MAApB,EAA4B;AACtC,WAAOA,MAAM,CAAC0B,IAAP,KAAgBY,EAAE,CAACd,IAA1B;AACD,GAJoB;AAKrBG,EAAAA,IAAI,EAAE,SAASA,IAAT,CAAcY,IAAd,EAAoB;AACxB,WAAO;AACLb,MAAAA,IAAI,EAAEY,EAAE,CAACd,IADJ;AAELe,MAAAA,IAAI,EAAEA,IAFD;AAGLzC,MAAAA,KAAK,EAAEL,KAAK,CAACE;AAHR,KAAP;AAKD,GAXoB;AAYrBiC,EAAAA,OAAO,EAAE,SAASA,OAAT,CAAiBW,IAAjB,EAAuB;AAC9B,WAAO;AACLb,MAAAA,IAAI,EAAEY,EAAE,CAACd,IADJ;AAELe,MAAAA,IAAI,EAAEA,IAFD;AAGLzC,MAAAA,KAAK,EAAEL,KAAK,CAACG;AAHR,KAAP;AAKD;AAlBoB,CAAd,CAAT;;AAqBA,IAAI4C,WAAW,GAAG,SAASA,WAAT,CAAqBC,EAArB,EAAyBC,EAAzB,EAA6B;AAC7C,MAAInD,WAAW,CAACkD,EAAD,CAAf,EAAqB;AACnB,WAAOjD,eAAe,CAACiD,EAAD,EAAKC,EAAL,CAAtB;AACD;;AAED,SAAOD,EAAE,KAAKC,EAAd;AACD,CAND;;AAQA,IAAIC,kBAAkB,GAAG,SAASA,kBAAT,CAA4BC,KAA5B,EAAmCnF,KAAnC,EAA0C;AACjE,SAAOmF,KAAK,CAACC,IAAN,CAAW,UAAUC,IAAV,EAAgB;AAChC,WAAON,WAAW,CAACM,IAAD,EAAOrF,KAAP,CAAlB;AACD,GAFM,CAAP;AAGD,CAJD;AAKA;;;;;;;;;;;;;;;;;;;;AAoBA,OAAO,IAAIsF,IAAI;AACf;AACA,YAAY;AACV5D,EAAAA,YAAY,CAAC4D,IAAD,EAAO,IAAP,EAAa,CAAC;AACxBzF,IAAAA,GAAG,EAAE,QADmB;AAExBG,IAAAA,KAAK,EAAE,SAASuF,MAAT,CAAgBC,OAAhB,EAAyB;AAC9B,aAAO,IAAIF,IAAJ,CAASE,OAAT,CAAP;AACD;AAJuB,GAAD,CAAb,CAAZ;;AAOA,WAASF,IAAT,GAAgB;AACd,QAAIE,OAAO,GAAGxG,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiByG,SAAzC,GAAqDzG,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAlF;;AAEAoC,IAAAA,eAAe,CAAC,IAAD,EAAOkE,IAAP,CAAf;;AAEA,SAAKI,QAAL,GAAgBF,OAAhB;AACA,SAAKG,eAAL,GAAuBH,OAAO,CAACI,MAAR,CAAe,UAAUC,GAAV,EAAetD,MAAf,EAAuB;AAC3D,cAAQA,MAAM,CAAC0B,IAAf;AACE,aAAKI,KAAK,CAACN,IAAX;AACE,cAAI,CAAC8B,GAAG,CAACtB,KAAJ,CAAUhC,MAAM,CAACgC,KAAjB,CAAL,EAA8B;AAC5BsB,YAAAA,GAAG,CAACtB,KAAJ,CAAUhC,MAAM,CAACgC,KAAjB,IAA0B,EAA1B;AACD;;AAEDsB,UAAAA,GAAG,CAACtB,KAAJ,CAAUhC,MAAM,CAACgC,KAAjB,EAAwBuB,IAAxB,CAA6BvD,MAA7B;AACA,iBAAOsD,GAAP;;AAEF,aAAKhB,EAAE,CAACd,IAAR;AACE8B,UAAAA,GAAG,CAACE,EAAJ,CAAOxD,MAAM,CAACuC,IAAd,IAAsBvC,MAAtB;AACA,iBAAOsD,GAAP;;AAEF,aAAK/B,IAAI,CAACC,IAAV;AACE8B,UAAAA,GAAG,CAACG,IAAJ,CAASF,IAAT,CAAcvD,MAAd;AACA,iBAAOsD,GAAP;;AAEF,aAAKzB,KAAK,CAACL,IAAX;AACE8B,UAAAA,GAAG,CAACI,KAAJ,CAAUH,IAAV,CAAevD,MAAf;AACA,iBAAOsD,GAAP;;AAEF;AACE,gBAAM,IAAIK,KAAJ,CAAU,8BAA8B3G,MAA9B,CAAqCgD,MAAM,CAAC0B,IAA5C,EAAkD,GAAlD,CAAV,CAAN;AAtBJ;AAwBD,KAzBsB,EAyBpB;AACDM,MAAAA,KAAK,EAAE,EADN;AAEDwB,MAAAA,EAAE,EAAE,EAFH;AAGDC,MAAAA,IAAI,EAAE,EAHL;AAIDC,MAAAA,KAAK,EAAE;AAJN,KAzBoB,CAAvB;AA+BD;;AAEDvE,EAAAA,YAAY,CAAC4D,IAAD,EAAO,CAAC;AAClBzF,IAAAA,GAAG,EAAE,gBADa;AAElBG,IAAAA,KAAK,EAAE,SAASmG,cAAT,GAA0B;AAC/B,aAAO,KAAKR,eAAL,CAAqBK,IAA5B;AACD;AAJiB,GAAD,EAKhB;AACDnG,IAAAA,GAAG,EAAE,eADJ;AAEDG,IAAAA,KAAK,EAAE,SAASoG,aAAT,CAAuBpG,KAAvB,EAA8B;AACnC,UAAIwF,OAAO,GAAG,KAAKW,cAAL,EAAd;AACA,aAAOX,OAAO,CAACa,IAAR,CAAa,UAAU9D,MAAV,EAAkB;AACpC,eAAOwC,WAAW,CAACxC,MAAM,CAACvC,KAAR,EAAeA,KAAf,CAAlB;AACD,OAFM,CAAP;AAGD;AAPA,GALgB,EAahB;AACDH,IAAAA,GAAG,EAAE,eADJ;AAEDG,IAAAA,KAAK,EAAE,SAASsG,aAAT,GAAyB;AAC9B,aAAOlH,MAAM,CAACC,IAAP,CAAY,KAAKsG,eAAL,CAAqBpB,KAAjC,CAAP;AACD;AAJA,GAbgB,EAkBhB;AACD1E,IAAAA,GAAG,EAAE,iBADJ;AAEDG,IAAAA,KAAK,EAAE,SAASuG,eAAT,GAA2B;AAChC,UAAIhC,KAAK,GAAGvF,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiByG,SAAzC,GAAqDzG,SAAS,CAAC,CAAD,CAA9D,GAAoEyG,SAAhF;AACA,aAAOlB,KAAK,GAAG,KAAKoB,eAAL,CAAqBpB,KAArB,CAA2BA,KAA3B,CAAH,GAAuC,KAAKmB,QAAL,CAAclG,MAAd,CAAqB6E,KAAK,CAACL,UAA3B,CAAnD;AACD;AALA,GAlBgB,EAwBhB;AACDnE,IAAAA,GAAG,EAAE,gBADJ;AAEDG,IAAAA,KAAK,EAAE,SAASwG,cAAT,CAAwBjC,KAAxB,EAA+BkC,SAA/B,EAA0C;AAC/C,UAAIjB,OAAO,GAAG,KAAKe,eAAL,CAAqBhC,KAArB,CAAd;;AAEA,UAAIiB,OAAJ,EAAa;AACX,eAAOA,OAAO,CAACa,IAAR,CAAaI,SAAb,CAAP;AACD;AACF;AARA,GAxBgB,EAiChB;AACD5G,IAAAA,GAAG,EAAE,kBADJ;AAEDG,IAAAA,KAAK,EAAE,SAAS0G,gBAAT,CAA0BnC,KAA1B,EAAiC;AACtC,UAAIvE,KAAK,GAAGhB,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiByG,SAAzC,GAAqDzG,SAAS,CAAC,CAAD,CAA9D,GAAoEyG,SAAhF;AACA,UAAID,OAAO,GAAG,KAAKgB,cAAL,CAAoBjC,KAApB,EAA2B,UAAUhC,MAAV,EAAkB;AACzD,eAAOrB,OAAO,CAACqB,MAAM,CAACvC,KAAR,CAAd;AACD,OAFa,CAAd;;AAIA,UAAI,CAACwF,OAAL,EAAc;AACZ,eAAO,KAAP;AACD;;AAED,aAAO3D,KAAK,CAAC7B,KAAD,CAAL,IAAgBwF,OAAO,CAACJ,IAAR,CAAa,UAAU7C,MAAV,EAAkB;AACpD,eAAO2C,kBAAkB,CAAC3C,MAAM,CAACvC,KAAR,EAAeA,KAAf,CAAzB;AACD,OAFsB,CAAvB;AAGD;AAfA,GAjCgB,EAiDhB;AACDH,IAAAA,GAAG,EAAE,kBADJ;AAEDG,IAAAA,KAAK,EAAE,SAAS2G,gBAAT,CAA0BpC,KAA1B,EAAiC;AACtC,UAAIvE,KAAK,GAAGhB,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiByG,SAAzC,GAAqDzG,SAAS,CAAC,CAAD,CAA9D,GAAoEyG,SAAhF;AACA,aAAO,KAAKe,cAAL,CAAoBjC,KAApB,EAA2B,UAAUhC,MAAV,EAAkB;AAClD,eAAOrB,OAAO,CAACqB,MAAM,CAACvC,KAAR,CAAP,KAA0B6B,KAAK,CAAC7B,KAAD,CAAL,IAAgBkF,kBAAkB,CAAC3C,MAAM,CAACvC,KAAR,EAAeA,KAAf,CAA5D,CAAP;AACD,OAFM,CAAP;AAGD;AAPA,GAjDgB,EAyDhB;AACDH,IAAAA,GAAG,EAAE,iBADJ;AAEDG,IAAAA,KAAK,EAAE,SAAS4G,eAAT,CAAyBrC,KAAzB,EAAgCvE,KAAhC,EAAuC;AAC5C,UAAIkE,IAAI,GAAGlF,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiByG,SAAzC,GAAqDzG,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAA/E;AACA,UAAIiE,QAAQ,GAAGjE,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiByG,SAAzC,GAAqDzG,SAAS,CAAC,CAAD,CAA9D,GAAoEwD,QAAQ,CAACC,EAA5F;AACA,UAAIoE,cAAc,GAAG,KAAKF,gBAAL,CAAsBpC,KAAtB,CAArB;;AAEA,UAAI,CAACsC,cAAL,EAAqB;AACnB,YAAIC,SAAS,GAAG5C,IAAI,GAAGG,KAAK,CAACH,IAAN,CAAWjB,QAAX,EAAqBsB,KAArB,EAA4B,CAACvE,KAAD,CAA5B,CAAH,GAA0CqE,KAAK,CAACF,OAAN,CAAclB,QAAd,EAAwBsB,KAAxB,EAA+B,CAACvE,KAAD,CAA/B,CAA9D;AACA,eAAO,IAAIsF,IAAJ,CAASlF,kBAAkB,CAAC,KAAKsF,QAAN,CAAlB,CAAkCnG,MAAlC,CAAyC,CAACuH,SAAD,CAAzC,CAAT,CAAP;AACD;;AAED,UAAItB,OAAO,GAAG,KAAKE,QAAL,CAAcG,GAAd,CAAkB,UAAUtD,MAAV,EAAkB;AAChD,YAAIA,MAAM,KAAKsE,cAAf,EAA+B;AAC7BtE,UAAAA,MAAM,CAACvC,KAAP,CAAa8F,IAAb,CAAkB9F,KAAlB;AACD;;AAED,eAAOuC,MAAP;AACD,OANa,CAAd;;AAQA,aAAO,IAAI+C,IAAJ,CAASE,OAAT,CAAP;AACD;AArBA,GAzDgB,EA+EhB;AACD3F,IAAAA,GAAG,EAAE,oBADJ;AAEDG,IAAAA,KAAK,EAAE,SAAS+G,kBAAT,CAA4BxC,KAA5B,EAAmCvE,KAAnC,EAA0C;AAC/C,UAAI6G,cAAc,GAAG,KAAKF,gBAAL,CAAsBpC,KAAtB,EAA6BvE,KAA7B,CAArB;;AAEA,UAAI,CAAC6G,cAAL,EAAqB;AACnB,eAAO,IAAIvB,IAAJ,CAASlF,kBAAkB,CAAC,KAAKsF,QAAN,CAA3B,CAAP;AACD;;AAED,UAAIF,OAAO,GAAG,KAAKE,QAAL,CAAcE,MAAd,CAAqB,UAAUJ,OAAV,EAAmBjD,MAAnB,EAA2B;AAC5D,YAAIA,MAAM,KAAKsE,cAAf,EAA+B;AAC7BrB,UAAAA,OAAO,CAACM,IAAR,CAAavD,MAAb;AACA,iBAAOiD,OAAP;AACD;;AAED,YAAIwB,aAAa,GAAGzE,MAAM,CAACvC,KAAP,CAAaR,MAAb,CAAoB,UAAUyH,GAAV,EAAe;AACrD,iBAAO,CAAClC,WAAW,CAACkC,GAAD,EAAMjH,KAAN,CAAnB;AACD,SAFmB,CAApB;;AAIA,YAAIgH,aAAa,CAAC/H,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,iBAAOuG,OAAP;AACD;;AAEDA,QAAAA,OAAO,CAACM,IAAR,CAAajH,aAAa,CAAC,EAAD,EAAK0D,MAAL,EAAa;AACrCvC,UAAAA,KAAK,EAAEgH;AAD8B,SAAb,CAA1B;AAGA,eAAOxB,OAAP;AACD,OAlBa,EAkBX,EAlBW,CAAd;;AAoBA,aAAO,IAAIF,IAAJ,CAASE,OAAT,CAAP;AACD;AA9BA,GA/EgB,EA8GhB;AACD3F,IAAAA,GAAG,EAAE,sBADJ;AAEDG,IAAAA,KAAK,EAAE,SAASkH,oBAAT,CAA8B3C,KAA9B,EAAqC;AAC1C,UAAIiB,OAAO,GAAG,KAAKE,QAAL,CAAclG,MAAd,CAAqB,UAAU+C,MAAV,EAAkB;AACnD,eAAO,CAAC8B,KAAK,CAACL,UAAN,CAAiBzB,MAAjB,CAAD,IAA6BA,MAAM,CAACgC,KAAP,KAAiBA,KAA9C,IAAuD,CAACrD,OAAO,CAACqB,MAAM,CAACvC,KAAR,CAAtE;AACD,OAFa,CAAd;;AAIA,aAAO,IAAIsF,IAAJ,CAASE,OAAT,CAAP;AACD;AARA,GA9GgB,EAuHhB;AACD3F,IAAAA,GAAG,EAAE,sBADJ;AAEDG,IAAAA,KAAK,EAAE,SAASmH,oBAAT,CAA8B5C,KAA9B,EAAqC;AAC1C,UAAIvE,KAAK,GAAGhB,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiByG,SAAzC,GAAqDzG,SAAS,CAAC,CAAD,CAA9D,GAAoEyG,SAAhF;AACA,UAAID,OAAO,GAAG,KAAKgB,cAAL,CAAoBjC,KAApB,EAA2B,UAAUhC,MAAV,EAAkB;AACzD,eAAO,CAACrB,OAAO,CAACqB,MAAM,CAACvC,KAAR,CAAf;AACD,OAFa,CAAd;;AAIA,UAAI,CAACwF,OAAL,EAAc;AACZ,eAAO,KAAP;AACD;;AAED,aAAO3D,KAAK,CAAC7B,KAAD,CAAL,IAAgBwF,OAAO,CAACJ,IAAR,CAAa,UAAU7C,MAAV,EAAkB;AACpD,eAAOwC,WAAW,CAACxC,MAAM,CAACvC,KAAR,EAAeA,KAAf,CAAlB;AACD,OAFsB,CAAvB;AAGD;AAfA,GAvHgB,EAuIhB;AACDH,IAAAA,GAAG,EAAE,sBADJ;AAEDG,IAAAA,KAAK,EAAE,SAASoH,oBAAT,CAA8B7C,KAA9B,EAAqC;AAC1C,UAAIvE,KAAK,GAAGhB,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiByG,SAAzC,GAAqDzG,SAAS,CAAC,CAAD,CAA9D,GAAoEyG,SAAhF;AACA,aAAO,KAAKe,cAAL,CAAoBjC,KAApB,EAA2B,UAAUhC,MAAV,EAAkB;AAClD,eAAO,CAACrB,OAAO,CAACqB,MAAM,CAACvC,KAAR,CAAR,KAA2B6B,KAAK,CAAC7B,KAAD,CAAL,IAAgB+E,WAAW,CAACxC,MAAM,CAACvC,KAAR,EAAeA,KAAf,CAAtD,CAAP;AACD,OAFM,CAAP;AAGD;AAPA,GAvIgB,EA+IhB;AACDH,IAAAA,GAAG,EAAE,qBADJ;AAEDG,IAAAA,KAAK,EAAE,SAASqH,mBAAT,CAA6B9C,KAA7B,EAAoCvE,KAApC,EAA2C;AAChD,UAAIkE,IAAI,GAAGlF,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiByG,SAAzC,GAAqDzG,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAA/E;AACA,UAAIiE,QAAQ,GAAGjE,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiByG,SAAzC,GAAqDzG,SAAS,CAAC,CAAD,CAA9D,GAAoEwD,QAAQ,CAACC,EAA5F;AACA,UAAIF,MAAM,GAAG2B,IAAI,GAAGG,KAAK,CAACH,IAAN,CAAWjB,QAAX,EAAqBsB,KAArB,EAA4BvE,KAA5B,CAAH,GAAwCqE,KAAK,CAACF,OAAN,CAAclB,QAAd,EAAwBsB,KAAxB,EAA+BvE,KAA/B,CAAzD;AACA,aAAO,KAAKsH,SAAL,CAAe/E,MAAf,CAAP;AACD;AAPA,GA/IgB,EAuJhB;AACD1C,IAAAA,GAAG,EAAE,wBADJ;AAEDG,IAAAA,KAAK,EAAE,SAASuH,sBAAT,CAAgChD,KAAhC,EAAuCvE,KAAvC,EAA8C;AACnD,UAAI6G,cAAc,GAAG,KAAKO,oBAAL,CAA0B7C,KAA1B,EAAiCvE,KAAjC,CAArB;;AAEA,UAAI,CAAC6G,cAAL,EAAqB;AACnB,eAAO,IAAIvB,IAAJ,CAASlF,kBAAkB,CAAC,KAAKsF,QAAN,CAA3B,CAAP;AACD;;AAED,UAAIF,OAAO,GAAG,KAAKE,QAAL,CAAclG,MAAd,CAAqB,UAAU+C,MAAV,EAAkB;AACnD,eAAOA,MAAM,KAAKsE,cAAlB;AACD,OAFa,CAAd;;AAIA,aAAO,IAAIvB,IAAJ,CAASE,OAAT,CAAP;AACD;AAdA,GAvJgB,EAsKhB;AACD3F,IAAAA,GAAG,EAAE,0BADJ;AAEDG,IAAAA,KAAK,EAAE,SAASwH,wBAAT,CAAkCjD,KAAlC,EAAyC;AAC9C,UAAIiB,OAAO,GAAG,KAAKE,QAAL,CAAclG,MAAd,CAAqB,UAAU+C,MAAV,EAAkB;AACnD,eAAO,CAAC8B,KAAK,CAACL,UAAN,CAAiBzB,MAAjB,CAAD,IAA6BA,MAAM,CAACgC,KAAP,KAAiBA,KAA9C,IAAuDrD,OAAO,CAACqB,MAAM,CAACvC,KAAR,CAArE;AACD,OAFa,CAAd;;AAIA,aAAO,IAAIsF,IAAJ,CAASE,OAAT,CAAP;AACD;AARA,GAtKgB,EA+KhB;AACD3F,IAAAA,GAAG,EAAE,cADJ;AAEDG,IAAAA,KAAK,EAAE,SAASyH,YAAT,GAAwB;AAC7B,aAAOrI,MAAM,CAACsI,MAAP,CAAc,KAAK/B,eAAL,CAAqBI,EAAnC,CAAP;AACD;AAJA,GA/KgB,EAoLhB;AACDlG,IAAAA,GAAG,EAAE,aADJ;AAEDG,IAAAA,KAAK,EAAE,SAAS2H,WAAT,CAAqB7C,IAArB,EAA2B;AAChC,aAAO,KAAKa,eAAL,CAAqBI,EAArB,CAAwBjB,IAAxB,CAAP;AACD;AAJA,GApLgB,EAyLhB;AACDjF,IAAAA,GAAG,EAAE,gBADJ;AAEDG,IAAAA,KAAK,EAAE,SAAS4H,cAAT,CAAwB9C,IAAxB,EAA8B;AACnC,aAAO,IAAIQ,IAAJ,CAAS,KAAKI,QAAL,CAAclG,MAAd,CAAqB,UAAU+C,MAAV,EAAkB;AACrD,eAAO,CAACsC,EAAE,CAACb,UAAH,CAAczB,MAAd,CAAD,IAA0BA,MAAM,CAACuC,IAAP,KAAgBA,IAAjD;AACD,OAFe,CAAT,CAAP;AAGD;AANA,GAzLgB,EAgMhB;AACDjF,IAAAA,GAAG,EAAE,iBADJ;AAEDG,IAAAA,KAAK,EAAE,SAAS6H,eAAT,GAA2B;AAChC,aAAOzI,MAAM,CAACsI,MAAP,CAAc,KAAK/B,eAAL,CAAqBM,KAAnC,CAAP;AACD;AACD;;;;;;;;;;;;;;;;;;;;AALC,GAhMgB,EAyNhB;AACDpG,IAAAA,GAAG,EAAE,WADJ;AAEDG,IAAAA,KAAK,EAAE,SAASsH,SAAT,CAAmBR,SAAnB,EAA8B;AACnC,UAAIgB,KAAK,GAAG,KAAZ;;AAEA,UAAIC,UAAU,GAAG,KAAKrC,QAAL,CAAcE,MAAd,CAAqB,UAAUJ,OAAV,EAAmBjD,MAAnB,EAA2B;AAC/D,YAAIuE,SAAS,CAAC7C,IAAV,KAAmB1B,MAAM,CAAC0B,IAA9B,EAAoC;AAClCuB,UAAAA,OAAO,CAACM,IAAR,CAAavD,MAAb;AACA,iBAAOiD,OAAP;AACD;;AAED,gBAAQsB,SAAS,CAAC7C,IAAlB;AACE,eAAKH,IAAI,CAACC,IAAV;AACE,gBAAI+C,SAAS,CAAC9G,KAAV,KAAoBuC,MAAM,CAACvC,KAA/B,EAAsC;AACpCwF,cAAAA,OAAO,CAACM,IAAR,CAAavD,MAAb;AACA,qBAAOiD,OAAP;AACD;;AAED;;AAEF,eAAKnB,KAAK,CAACN,IAAX;AACE,gBAAI+C,SAAS,CAACvC,KAAV,KAAoBhC,MAAM,CAACgC,KAA3B,IAAoCuC,SAAS,CAAC9G,KAAV,KAAoBuC,MAAM,CAACvC,KAAnE,EAA0E;AACxEwF,cAAAA,OAAO,CAACM,IAAR,CAAavD,MAAb;AACA,qBAAOiD,OAAP;AACD;;AAED;;AAEF,eAAKX,EAAE,CAACd,IAAR;AACE,gBAAI+C,SAAS,CAAChC,IAAV,KAAmBvC,MAAM,CAACuC,IAA9B,EAAoC;AAClCU,cAAAA,OAAO,CAACM,IAAR,CAAavD,MAAb;AACA,qBAAOiD,OAAP;AACD;;AAED;;AAEF;AACE,kBAAM,IAAIU,KAAJ,CAAU,wBAAwB3G,MAAxB,CAA+BuH,SAAS,CAAC7C,IAAzC,EAA+C,GAA/C,CAAV,CAAN;AA1BJ;;AA6BA6D,QAAAA,KAAK,GAAG,IAAR;AACAtC,QAAAA,OAAO,CAACM,IAAR,CAAagB,SAAb;AACA,eAAOtB,OAAP;AACD,OAtCgB,EAsCd,EAtCc,CAAjB;;AAwCA,UAAI,CAACsC,KAAL,EAAY;AACVC,QAAAA,UAAU,CAACjC,IAAX,CAAgBgB,SAAhB;AACD;;AAED,aAAO,IAAIxB,IAAJ,CAASyC,UAAT,CAAP;AACD;AAlDA,GAzNgB,EA4QhB;AACDlI,IAAAA,GAAG,EAAE,SADJ;AAEDmI,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAKtC,QAAZ;AACD;AAJA,GA5QgB,CAAP,CAAZ;;AAmRA,SAAOJ,IAAP;AACD,CAnUD,EAFO;AAsUP,OAAO,IAAI2C,GAAG,GAAG7I,MAAM,CAAC6C,MAAP,CAAc;AAC7BD,EAAAA,KAAK,EAAEA,KADsB;AAE7BQ,EAAAA,QAAQ,EAAEA,QAFmB;AAG7BsB,EAAAA,IAAI,EAAEA,IAHuB;AAI7BM,EAAAA,KAAK,EAAEA,KAJsB;AAK7BC,EAAAA,KAAK,EAAEA,KALsB;AAM7BQ,EAAAA,EAAE,EAAEA,EANyB;AAO7BU,EAAAA,MAAM,EAAE,SAASA,MAAT,CAAgBC,OAAhB,EAAyB;AAC/B,WAAO,IAAIF,IAAJ,CAASE,OAAT,CAAP;AACD;AAT4B,CAAd,CAAV","sourcesContent":["function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { isArray, isNil } from '../../../services/predicate';\nimport { isDateValue, dateValuesEqual } from './date_value';\nexport var Match = Object.freeze({\n  MUST: 'must',\n  MUST_NOT: 'must_not',\n  isMust: function isMust(match) {\n    return match === Match.MUST;\n  },\n  isMustClause: function isMustClause(clause) {\n    return Match.isMust(clause.match);\n  }\n});\nexport var Operator = Object.freeze({\n  EQ: 'eq',\n  EXACT: 'exact',\n  GT: 'gt',\n  GTE: 'gte',\n  LT: 'lt',\n  LTE: 'lte',\n  isEQ: function isEQ(match) {\n    return match === Operator.EQ;\n  },\n  isEQClause: function isEQClause(clause) {\n    return Operator.isEQ(clause.operator);\n  },\n  isEXACT: function isEXACT(match) {\n    return match === Operator.EXACT;\n  },\n  isEXACTClause: function isEXACTClause(clause) {\n    return Operator.isEXACT(clause.operator);\n  },\n  isRange: function isRange(match) {\n    return Operator.isGT(match) || Operator.isGTE(match) || Operator.isLT(match) || Operator.isLTE(match);\n  },\n  isRangeClause: function isRangeClause(clause) {\n    return Operator.isRange(clause.operator);\n  },\n  isGT: function isGT(match) {\n    return match === Operator.GT;\n  },\n  isGTClause: function isGTClause(clause) {\n    return Operator.isGT(clause.operator);\n  },\n  isGTE: function isGTE(match) {\n    return match === Operator.GTE;\n  },\n  isGTEClause: function isGTEClause(clause) {\n    return Operator.isGTE(clause.operator);\n  },\n  isLT: function isLT(match) {\n    return match === Operator.LT;\n  },\n  isLTClause: function isLTClause(clause) {\n    return Operator.isLT(clause.operator);\n  },\n  isLTE: function isLTE(match) {\n    return match === Operator.LTE;\n  },\n  isLTEClause: function isLTEClause(clause) {\n    return Operator.isLTE(clause.operator);\n  }\n});\nvar Term = Object.freeze({\n  TYPE: 'term',\n  isInstance: function isInstance(clause) {\n    return clause.type === Term.TYPE;\n  },\n  must: function must(value) {\n    return {\n      type: Term.TYPE,\n      value: value,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(value) {\n    return {\n      type: Term.TYPE,\n      value: value,\n      match: Match.MUST_NOT\n    };\n  }\n});\nvar Group = Object.freeze({\n  TYPE: 'group',\n  isInstance: function isInstance(clause) {\n    return clause.type === Group.TYPE;\n  },\n  must: function must(value) {\n    return {\n      type: Group.TYPE,\n      value: value,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(value) {\n    return {\n      type: Group.TYPE,\n      value: value,\n      match: Match.MUST_NOT\n    };\n  }\n});\nvar Field = Object.freeze({\n  TYPE: 'field',\n  isInstance: function isInstance(clause) {\n    return clause.type === Field.TYPE;\n  },\n  must: {\n    eq: function eq(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.EQ\n      };\n    },\n    exact: function exact(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.EXACT\n      };\n    },\n    gt: function gt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.GT\n      };\n    },\n    gte: function gte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.GTE\n      };\n    },\n    lt: function lt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.LT\n      };\n    },\n    lte: function lte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST,\n        operator: Operator.LTE\n      };\n    }\n  },\n  mustNot: {\n    eq: function eq(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.EQ\n      };\n    },\n    exact: function exact(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.EXACT\n      };\n    },\n    gt: function gt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.GT\n      };\n    },\n    gte: function gte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.GTE\n      };\n    },\n    lt: function lt(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.LT\n      };\n    },\n    lte: function lte(field, value) {\n      return {\n        type: Field.TYPE,\n        field: field,\n        value: value,\n        match: Match.MUST_NOT,\n        operator: Operator.LTE\n      };\n    }\n  }\n});\nvar Is = Object.freeze({\n  TYPE: 'is',\n  isInstance: function isInstance(clause) {\n    return clause.type === Is.TYPE;\n  },\n  must: function must(flag) {\n    return {\n      type: Is.TYPE,\n      flag: flag,\n      match: Match.MUST\n    };\n  },\n  mustNot: function mustNot(flag) {\n    return {\n      type: Is.TYPE,\n      flag: flag,\n      match: Match.MUST_NOT\n    };\n  }\n});\n\nvar valuesEqual = function valuesEqual(v1, v2) {\n  if (isDateValue(v1)) {\n    return dateValuesEqual(v1, v2);\n  }\n\n  return v1 === v2;\n};\n\nvar arrayIncludesValue = function arrayIncludesValue(array, value) {\n  return array.some(function (item) {\n    return valuesEqual(item, value);\n  });\n};\n/**\n * The AST structure is an array of clauses. There are 3 types of clauses that are supported:\n *\n * :term:\n * Holds a VALUE and an OCCUR. The OCCUR indicates whether the value must match or must not match. Default\n * clauses are not associated with any specific field - when executing the search, one can specify what are\n * the default fields that the default clauses will be matched against.\n *\n * :field:\n * Like the `term` clause, holds a VALUE and an MATCH, but this clause also specifies the field that the\n * value will be matched against.\n *\n * :is:\n * Holds a FLAG and indicates whether this flag must be applied or must not be applied. Typically this clause\n * matches against boolean values of a record (e.g. \"is:online\", \"is:internal\", \"is:on\", etc..)\n *\n * This AST is immutable - every \"mutating\" operation returns a newly mutated AST.\n */\n\n\nexport var _AST =\n/*#__PURE__*/\nfunction () {\n  _createClass(_AST, null, [{\n    key: \"create\",\n    value: function create(clauses) {\n      return new _AST(clauses);\n    }\n  }]);\n\n  function _AST() {\n    var clauses = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, _AST);\n\n    this._clauses = clauses;\n    this._indexedClauses = clauses.reduce(function (map, clause) {\n      switch (clause.type) {\n        case Field.TYPE:\n          if (!map.field[clause.field]) {\n            map.field[clause.field] = [];\n          }\n\n          map.field[clause.field].push(clause);\n          return map;\n\n        case Is.TYPE:\n          map.is[clause.flag] = clause;\n          return map;\n\n        case Term.TYPE:\n          map.term.push(clause);\n          return map;\n\n        case Group.TYPE:\n          map.group.push(clause);\n          return map;\n\n        default:\n          throw new Error(\"Unknown query clause type [\".concat(clause.type, \"]\"));\n      }\n    }, {\n      field: {},\n      is: {},\n      term: [],\n      group: []\n    });\n  }\n\n  _createClass(_AST, [{\n    key: \"getTermClauses\",\n    value: function getTermClauses() {\n      return this._indexedClauses.term;\n    }\n  }, {\n    key: \"getTermClause\",\n    value: function getTermClause(value) {\n      var clauses = this.getTermClauses();\n      return clauses.find(function (clause) {\n        return valuesEqual(clause.value, value);\n      });\n    }\n  }, {\n    key: \"getFieldNames\",\n    value: function getFieldNames() {\n      return Object.keys(this._indexedClauses.field);\n    }\n  }, {\n    key: \"getFieldClauses\",\n    value: function getFieldClauses() {\n      var field = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      return field ? this._indexedClauses.field[field] : this._clauses.filter(Field.isInstance);\n    }\n  }, {\n    key: \"getFieldClause\",\n    value: function getFieldClause(field, predicate) {\n      var clauses = this.getFieldClauses(field);\n\n      if (clauses) {\n        return clauses.find(predicate);\n      }\n    }\n  }, {\n    key: \"hasOrFieldClause\",\n    value: function hasOrFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var clauses = this.getFieldClause(field, function (clause) {\n        return isArray(clause.value);\n      });\n\n      if (!clauses) {\n        return false;\n      }\n\n      return isNil(value) || clauses.some(function (clause) {\n        return arrayIncludesValue(clause.value, value);\n      });\n    }\n  }, {\n    key: \"getOrFieldClause\",\n    value: function getOrFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return this.getFieldClause(field, function (clause) {\n        return isArray(clause.value) && (isNil(value) || arrayIncludesValue(clause.value, value));\n      });\n    }\n  }, {\n    key: \"addOrFieldValue\",\n    value: function addOrFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Operator.EQ;\n      var existingClause = this.getOrFieldClause(field);\n\n      if (!existingClause) {\n        var newClause = must ? Field.must[operator](field, [value]) : Field.mustNot[operator](field, [value]);\n        return new _AST(_toConsumableArray(this._clauses).concat([newClause]));\n      }\n\n      var clauses = this._clauses.map(function (clause) {\n        if (clause === existingClause) {\n          clause.value.push(value);\n        }\n\n        return clause;\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeOrFieldValue\",\n    value: function removeOrFieldValue(field, value) {\n      var existingClause = this.getOrFieldClause(field, value);\n\n      if (!existingClause) {\n        return new _AST(_toConsumableArray(this._clauses));\n      }\n\n      var clauses = this._clauses.reduce(function (clauses, clause) {\n        if (clause !== existingClause) {\n          clauses.push(clause);\n          return clauses;\n        }\n\n        var filteredValue = clause.value.filter(function (val) {\n          return !valuesEqual(val, value);\n        });\n\n        if (filteredValue.length === 0) {\n          return clauses;\n        }\n\n        clauses.push(_objectSpread({}, clause, {\n          value: filteredValue\n        }));\n        return clauses;\n      }, []);\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeOrFieldClauses\",\n    value: function removeOrFieldClauses(field) {\n      var clauses = this._clauses.filter(function (clause) {\n        return !Field.isInstance(clause) || clause.field !== field || !isArray(clause.value);\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"hasSimpleFieldClause\",\n    value: function hasSimpleFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      var clauses = this.getFieldClause(field, function (clause) {\n        return !isArray(clause.value);\n      });\n\n      if (!clauses) {\n        return false;\n      }\n\n      return isNil(value) || clauses.some(function (clause) {\n        return valuesEqual(clause.value, value);\n      });\n    }\n  }, {\n    key: \"getSimpleFieldClause\",\n    value: function getSimpleFieldClause(field) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      return this.getFieldClause(field, function (clause) {\n        return !isArray(clause.value) && (isNil(value) || valuesEqual(clause.value, value));\n      });\n    }\n  }, {\n    key: \"addSimpleFieldValue\",\n    value: function addSimpleFieldValue(field, value) {\n      var must = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var operator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Operator.EQ;\n      var clause = must ? Field.must[operator](field, value) : Field.mustNot[operator](field, value);\n      return this.addClause(clause);\n    }\n  }, {\n    key: \"removeSimpleFieldValue\",\n    value: function removeSimpleFieldValue(field, value) {\n      var existingClause = this.getSimpleFieldClause(field, value);\n\n      if (!existingClause) {\n        return new _AST(_toConsumableArray(this._clauses));\n      }\n\n      var clauses = this._clauses.filter(function (clause) {\n        return clause !== existingClause;\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"removeSimpleFieldClauses\",\n    value: function removeSimpleFieldClauses(field) {\n      var clauses = this._clauses.filter(function (clause) {\n        return !Field.isInstance(clause) || clause.field !== field || isArray(clause.value);\n      });\n\n      return new _AST(clauses);\n    }\n  }, {\n    key: \"getIsClauses\",\n    value: function getIsClauses() {\n      return Object.values(this._indexedClauses.is);\n    }\n  }, {\n    key: \"getIsClause\",\n    value: function getIsClause(flag) {\n      return this._indexedClauses.is[flag];\n    }\n  }, {\n    key: \"removeIsClause\",\n    value: function removeIsClause(flag) {\n      return new _AST(this._clauses.filter(function (clause) {\n        return !Is.isInstance(clause) || clause.flag !== flag;\n      }));\n    }\n  }, {\n    key: \"getGroupClauses\",\n    value: function getGroupClauses() {\n      return Object.values(this._indexedClauses.group);\n    }\n    /**\n     * Creates and returns a new AST with the given clause added to the current clauses. If\n     * the current clauses already include a similar clause, it will be (in-place) replaced by\n     * the given clause. Whether a clause is similar to the given one depends on the type of the clause.\n     * Two clauses are similar if:\n     *\n     * - they are both of the same type\n     * - if they are `default` clauses, they must have the same value\n     * - if they are `term` clauses, they must have the same fields and values\n     * - if they are `is` clauses, they must have the same flags\n     *\n     * The reasoning behind not including the `match` attributes of the clauses in the rules above, stems\n     * in the fact that the AST clauses are ANDed, and having two similar clauses with two different\n     * match attributes creates a logically contradicted AST (e.g. what does it mean to\n     * \"(must have x) AND (must not have x)\"?)\n     *\n     * note:  in-place replacement means the given clause will be placed in the same position as the one it\n     *        replaced\n     */\n\n  }, {\n    key: \"addClause\",\n    value: function addClause(newClause) {\n      var added = false;\n\n      var newClauses = this._clauses.reduce(function (clauses, clause) {\n        if (newClause.type !== clause.type) {\n          clauses.push(clause);\n          return clauses;\n        }\n\n        switch (newClause.type) {\n          case Term.TYPE:\n            if (newClause.value !== clause.value) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          case Field.TYPE:\n            if (newClause.field !== clause.field || newClause.value !== clause.value) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          case Is.TYPE:\n            if (newClause.flag !== clause.flag) {\n              clauses.push(clause);\n              return clauses;\n            }\n\n            break;\n\n          default:\n            throw new Error(\"unknown clause type [\".concat(newClause.type, \"]\"));\n        }\n\n        added = true;\n        clauses.push(newClause);\n        return clauses;\n      }, []);\n\n      if (!added) {\n        newClauses.push(newClause);\n      }\n\n      return new _AST(newClauses);\n    }\n  }, {\n    key: \"clauses\",\n    get: function get() {\n      return this._clauses;\n    }\n  }]);\n\n  return _AST;\n}();\nexport var AST = Object.freeze({\n  Match: Match,\n  Operator: Operator,\n  Term: Term,\n  Group: Group,\n  Field: Field,\n  Is: Is,\n  create: function create(clauses) {\n    return new _AST(clauses);\n  }\n});"]},"metadata":{},"sourceType":"module"}